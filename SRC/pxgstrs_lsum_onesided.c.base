@extract -b Typedef.inc

#include "superlu_@(pre)defs.h"
#include "superlu_defs.h"

#ifndef CACHELINE
#define CACHELINE 64  /* bytes, Xeon Phi KNL, Cori haswell, Edision */
#endif

#define ISEND_IRECV

/*
 * Function prototypes
 */
#ifdef _CRAY
fortran void @(SC_PRE)TRSM(_fcd, _fcd, _fcd, _fcd, int*, int*, @(type)*,
		   @(type)*, int*, @(type)*, int*);
fortran void @(SC_PRE)GEMM(_fcd, _fcd, int*, int*, int*, @(type)*, @(type)*,
		   int*, @(type)*, int*, @(type)*, @(type)*, int*);
_fcd ftcs1;
_fcd ftcs2;
_fcd ftcs3;
#endif

#ifdef one_sided
/************************************************************************/
/*! \brief
 *
 * <pre>
 * Purpose
 * =======
 *   Perform local block modifications: lsum[i] -= L_i,k * X[k].
 * </pre>
 */
void @(pre)lsum_fmod_inv_master_onesided
/************************************************************************/
(
 @(type) *lsum,    /* Sum of local modifications.                        */
 @(type) *x,       /* X array (local)                                    */
 @(type) *xk,      /* X[k].                                              */
 @(type) *rtemp,   /* Result of full matrix-vector multiply.             */
 int   nrhs,      /* Number of right-hand sides.                        */
 int   knsupc,    /* Size of supernode k.                               */
 int_t k,         /* The k-th component of X.                           */
 int *fmod,     /* Modification count for L-solve.                    */
 int_t nlb,       /* Number of L blocks.                                */
 int_t *xsup,
 gridinfo_t *grid,
 @(pre)LocalLU_t *Llu,
 SuperLUStat_t **stat,
 int_t sizelsum,
 int_t sizertemp,
 int_t recurlevel,
 int_t maxsuper,
 int thread_id,
 int num_thread,
 int* RDcount,
 long* RDbase,
 int* BCcount,
 long* BCbase,
 int Pc,
 int maxrecvsz
)
{
@precision SINGLE DOUBLE
    @(type) alpha = 1.0, beta = 0.0, malpha=-1.0;
@precision SCOMPLEX DCOMPLEX
    @(type) alpha = {1.0, 0.0}, beta = {0.0, 0.0},malpha={-1.0, 0.0};
@precision !
    @(type) *lusup, *lusup1;
    @(type) *dest;
	@(type) *Linv;/* Inverse of diagonal block */
	int    iam, iknsupc, myrow, krow, nbrow, nbrow1, nbrow_ref, nsupr, nsupr1, p, pi, idx_r;
	int_t  i, ii,jj, ik, il, ikcol, irow, j, lb, lk, rel, lib,lready;
	int_t  *lsub, *lsub1, nlb1, lptr1, luptr1,*lloc;
    int_t  *ilsum = Llu->ilsum; /* Starting position of each supernode in lsum.   */
    int  *frecv = Llu->frecv;
    int  **fsendx_plist = Llu->fsendx_plist;
	int_t  luptr_tmp,luptr_tmp1,lptr1_tmp, idx_i, idx_v,idx_n,  idx_l, fmod_tmp, lbstart,lbend,nn,Nchunk,nlb_loc,remainder;
	int thread_id1;
	int m;
	flops_t ops_loc=0.0;
    MPI_Status status;
    int test_flag;
	yes_no_t done;
	C_Tree  *LBtree_ptr = Llu->LBtree_ptr;
	C_Tree  *LRtree_ptr = Llu->LRtree_ptr;
	int_t* idx_lsum,idx_lsum1;
	@(type) *rtemp_loc;
	int_t ldalsum;
	int_t nleaf_send_tmp;
	int_t lptr;      /* Starting position in lsub[*].                      */
	int_t luptr;     /* Starting position in lusup[*].                     */
	int_t iword = sizeof(int_t);
	int_t dword = sizeof (@(mod_type));
	int aln_d,aln_i;
	aln_d = 1; //ceil(CACHELINE/(double)dword);
	aln_i = 1; //ceil(CACHELINE/(double)iword);

	ldalsum=Llu->ldalsum;

	rtemp_loc = &rtemp[sizertemp* thread_id];

	// #if ( PROFlevel>=1 )
	double t1, t2, t3, t4;
	float msg_vol = 0, msg_cnt = 0;
	// #endif

	if(nlb>0){

		iam = grid->iam;
		myrow = MYROW( iam, grid );
		lk = LBj( k, grid ); /* Local block number, column-wise. */

		// printf("ya1 %5d k %5d lk %5d\n",thread_id,k,lk);
		// fflush(stdout);

		lsub = Llu->Lrowind_bc_ptr[lk];

		// printf("ya2 %5d k %5d lk %5d\n",thread_id,k,lk);
		// fflush(stdout);

		lusup = Llu->Lnzval_bc_ptr[lk];
		lloc = Llu->Lindval_loc_bc_ptr[lk];
		// idx_lsum = Llu->Lrowind_bc_2_lsum[lk];

		nsupr = lsub[1];

		// printf("nlb: %5d lk: %5d\n",nlb,lk);
		// fflush(stdout);

		krow = PROW( k, grid );
		if(myrow==krow){
			idx_n = 1;
			idx_i = nlb+2;
			idx_v = 2*nlb+3;
			luptr_tmp = lloc[idx_v];
			m = nsupr-knsupc;
		}else{
			idx_n = 0;
			idx_i = nlb;
			idx_v = 2*nlb;
			luptr_tmp = lloc[idx_v];
			m = nsupr;
		}

		assert(m>0);

		if(m>4*maxsuper || nrhs>10){
			// if(m<1){
			// TIC(t1);
			Nchunk=num_thread;
			nlb_loc = floor(((double)nlb)/Nchunk);
			remainder = nlb % Nchunk;

#ifdef _OPENMP
#pragma	omp	taskloop private (lptr1,luptr1,nlb1,thread_id1,lsub1,lusup1,nsupr1,Linv,nn,lbstart,lbend,luptr_tmp1,nbrow,lb,lptr1_tmp,rtemp_loc,nbrow_ref,lptr,nbrow1,ik,rel,lk,iknsupc,il,i,irow,fmod_tmp,ikcol,p,ii,jj,t1,t2,j) untied
#endif
			for (nn=0;nn<Nchunk;++nn){

#ifdef _OPENMP
				thread_id1 = omp_get_thread_num ();
#else
				thread_id1 = 0;
#endif
				rtemp_loc = &rtemp[sizertemp* thread_id1];

				if(nn<remainder){
					lbstart = nn*(nlb_loc+1);
					lbend = (nn+1)*(nlb_loc+1);
				}else{
					lbstart = remainder+nn*nlb_loc;
					lbend = remainder + (nn+1)*nlb_loc;
				}

				if(lbstart<lbend){

#if ( PROFlevel>=1 )
					TIC(t1);
#endif
					luptr_tmp1 = lloc[lbstart+idx_v];
					nbrow=0;
					for (lb = lbstart; lb < lbend; ++lb){
						lptr1_tmp = lloc[lb+idx_i];
						nbrow += lsub[lptr1_tmp+1];
					}

				#ifdef _CRAY
					@(SC_PRE)GEMM( ftcs2, ftcs2, &nbrow, &nrhs, &knsupc,
						  &alpha, &lusup[luptr_tmp1], &nsupr, xk,
						  &knsupc, &beta, rtemp_loc, &nbrow );
				#elif defined (USE_VENDOR_BLAS)
					@(pre)gemm_( "N", "N", &nbrow, &nrhs, &knsupc,
						   &alpha, &lusup[luptr_tmp1], &nsupr, xk,
						   &knsupc, &beta, rtemp_loc, &nbrow, 1, 1 );
				#else
					@(pre)gemm_( "N", "N", &nbrow, &nrhs, &knsupc,
						   &alpha, &lusup[luptr_tmp1], &nsupr, xk,
						   &knsupc, &beta, rtemp_loc, &nbrow );
				#endif

					nbrow_ref=0;
					for (lb = lbstart; lb < lbend; ++lb){
						lptr1_tmp = lloc[lb+idx_i];
						lptr= lptr1_tmp+2;
						nbrow1 = lsub[lptr1_tmp+1];
						ik = lsub[lptr1_tmp]; /* Global block number, row-wise. */
						rel = xsup[ik]; /* Global row index of block ik. */

						lk = LBi( ik, grid ); /* Local block number, row-wise. */

						iknsupc = SuperSize( ik );
						il = LSUM_BLK( lk );

						RHS_ITERATE(j)
					#ifdef _OPENMP
					#pragma omp simd lastprivate(irow)
					#endif
							for (i = 0; i < nbrow1; ++i) {
								irow = lsub[lptr+i] - rel; /* Relative row. */
@precision SINGLE DOUBLE
								lsum[il+irow + j*iknsupc] -= rtemp_loc[nbrow_ref+i + j*nbrow];
@precision SCOMPLEX DCOMPLEX
								@(pre)_sub(&lsum[il+irow + j*iknsupc],
									  &lsum[il+irow + j*iknsupc],
									  &rtemp_loc[nbrow_ref+i + j*nbrow]);
@precision !
							}
						nbrow_ref+=nbrow1;
					} /* end for lb ... */

#if ( PROFlevel>=1 )
					TOC(t2, t1);
					stat[thread_id1]->utime[SOL_GEMM] += t2;
#endif
			} /* end if (lbstart<lbend) ... */

		} /* end taskloop for nn = ... */

		}else{

#if ( PROFlevel>=1 )
			TIC(t1);
#endif

#ifdef _CRAY
			@(SC_PRE)GEMM( ftcs2, ftcs2, &m, &nrhs, &knsupc,
					&alpha, &lusup[luptr_tmp], &nsupr, xk,
					&knsupc, &beta, rtemp_loc, &m );
#elif defined (USE_VENDOR_BLAS)
			@(pre)gemm_( "N", "N", &m, &nrhs, &knsupc,
					&alpha, &lusup[luptr_tmp], &nsupr, xk,
					&knsupc, &beta, rtemp_loc, &m, 1, 1 );
#else
			@(pre)gemm_( "N", "N", &m, &nrhs, &knsupc,
					&alpha, &lusup[luptr_tmp], &nsupr, xk,
					&knsupc, &beta, rtemp_loc, &m );
#endif

			nbrow=0;
			for (lb = 0; lb < nlb; ++lb){
				lptr1_tmp = lloc[lb+idx_i];
				nbrow += lsub[lptr1_tmp+1];
			}
			nbrow_ref=0;
			for (lb = 0; lb < nlb; ++lb){
				lptr1_tmp = lloc[lb+idx_i];
				lptr= lptr1_tmp+2;
				nbrow1 = lsub[lptr1_tmp+1];
				ik = lsub[lptr1_tmp]; /* Global block number, row-wise. */
				rel = xsup[ik]; /* Global row index of block ik. */

				lk = LBi( ik, grid ); /* Local block number, row-wise. */

				iknsupc = SuperSize( ik );
				il = LSUM_BLK( lk );

				RHS_ITERATE(j)
			#ifdef _OPENMP
			#pragma omp simd lastprivate(irow)
			#endif
					for (i = 0; i < nbrow1; ++i) {
						irow = lsub[lptr+i] - rel; /* Relative row. */

@precision SINGLE DOUBLE
						lsum[il+irow + j*iknsupc+sizelsum*thread_id] -= rtemp_loc[nbrow_ref+i + j*nbrow];
@precision SCOMPLEX DCOMPLEX
						@(pre)_sub(&lsum[il+irow + j*iknsupc+sizelsum*thread_id],
							  &lsum[il+irow + j*iknsupc+sizelsum*thread_id],
							  &rtemp_loc[nbrow_ref+i + j*nbrow]);
@precision !
					}
				nbrow_ref+=nbrow1;
			} /* end for lb ... */
#if ( PROFlevel>=1 )
			TOC(t2, t1);
			stat[thread_id]->utime[SOL_GEMM] += t2;
#endif
		} /* end else ... */
		// TOC(t3, t1);
		rtemp_loc = &rtemp[sizertemp* thread_id];

		for (lb=0;lb<nlb;lb++){
			lk = lloc[lb+idx_n];

			// #ifdef _OPENMP
			// #pragma omp atomic capture
			// #endif
			fmod_tmp=--fmod[lk*aln_i];


			if ( fmod_tmp==0 ) { /* Local accumulation done. */
				// --fmod[lk];


				lptr1_tmp = lloc[lb+idx_i];
				// luptr_tmp = lloc[lb+idx_v];

				ik = lsub[lptr1_tmp]; /* Global block number, row-wise. */
				lk = LBi( ik, grid ); /* Local block number, row-wise. */

				iknsupc = SuperSize( ik );
				il = LSUM_BLK( lk );

				// nbrow = lsub[lptr1_tmp+1];

				ikcol = PCOL( ik, grid );
				p = PNUM( myrow, ikcol, grid );
				if ( iam != p ) {
					// if(frecv[lk]==0){
					// fmod[lk] = -1;

					for (ii=1;ii<num_thread;ii++)
						// if(ii!=thread_id)
				#ifdef _OPENMP
				#pragma omp simd
				#endif
						for (jj=0;jj<iknsupc*nrhs;jj++)
@precision SINGLE DOUBLE
							lsum[il + jj ] += lsum[il + jj + ii*sizelsum];
@precision SCOMPLEX DCOMPLEX
							@(pre)_add(&lsum[il + jj ],
								  &lsum[il + jj ],
								  &lsum[il + jj + ii*sizelsum]);
@precision !

					// RdTree_forwardMessageSimple(LRtree_ptr[lk],&lsum[il - LSUM_H ],RdTree_GetMsgSize(LRtree_ptr[lk],'@(pre)')*nrhs+LSUM_H,'@(pre)');
					//C_RdTree_forwardMessageSimple(&LRtree_ptr[lk],&lsum[il - LSUM_H ],LRtree_ptr[lk].msgSize_*nrhs+LSUM_H);
					C_RdTree_forwardMessage_onesided(&LRtree_ptr[lk],&lsum[il - LSUM_H ],LRtree_ptr[lk].msgSize_*nrhs+LSUM_H, RDcount, RDbase, &maxrecvsz, Pc);
					// }


				} else { /* Diagonal process: X[i] += lsum[i]. */

					// if ( frecv[lk]==0 ) { /* Becomes a leaf node. */
#if ( PROFlevel>=1 )
					TIC(t1);
#endif
					for (ii=1;ii<num_thread;ii++)
						// if(ii!=thread_id)
				#ifdef _OPENMP
				#pragma omp simd
				#endif
						for (jj=0;jj<iknsupc*nrhs;jj++)
@precision SINGLE DOUBLE
							lsum[il + jj ] += lsum[il + jj + ii*sizelsum];
@precision SCOMPLEX DCOMPLEX
							@(pre)_add(&lsum[il + jj ],
								  &lsum[il + jj ],
								  &lsum[il + jj + ii*sizelsum]);
@precision !

					ii = X_BLK( lk );
					// for (jj=0;jj<num_thread;jj++)
					RHS_ITERATE(j)
				#ifdef _OPENMP
				#pragma omp simd
				#endif
						for (i = 0; i < iknsupc; ++i)
@precision SINGLE DOUBLE
							x[i + ii + j*iknsupc] += lsum[i + il + j*iknsupc ];
@precision SCOMPLEX DCOMPLEX
							@(pre)_add(&x[i + ii + j*iknsupc],
								  &x[i + ii + j*iknsupc],
								  &lsum[i + il + j*iknsupc] );
@precision !

					// fmod[lk] = -1; /* Do not solve X[k] in the future. */
					lk = LBj( ik, grid );/* Local block number, column-wise. */
					lsub1 = Llu->Lrowind_bc_ptr[lk];
					lusup1 = Llu->Lnzval_bc_ptr[lk];
					nsupr1 = lsub1[1];

					if(Llu->inv == 1){
						Linv = Llu->Linv_bc_ptr[lk];
#ifdef _CRAY
						@(SC_PRE)GEMM( ftcs2, ftcs2, &iknsupc, &nrhs, &iknsupc,
								&alpha, Linv, &iknsupc, &x[ii],
								&iknsupc, &beta, rtemp_loc, &iknsupc );
#elif defined (USE_VENDOR_BLAS)
						@(pre)gemm_( "N", "N", &iknsupc, &nrhs, &iknsupc,
								&alpha, Linv, &iknsupc, &x[ii],
								&iknsupc, &beta, rtemp_loc, &iknsupc, 1, 1 );
#else
						@(pre)gemm_( "N", "N", &iknsupc, &nrhs, &iknsupc,
								&alpha, Linv, &iknsupc, &x[ii],
								&iknsupc, &beta, rtemp_loc, &iknsupc );
#endif
				#ifdef _OPENMP
				#pragma omp simd
				#endif
						for (i=0 ; i<iknsupc*nrhs ; i++){
@precision SINGLE DOUBLE
							x[ii+i] = rtemp_loc[i];
@precision SCOMPLEX DCOMPLEX
							@(pre)_copy(&x[ii+i],&rtemp_loc[i]);
@precision !
						}
					}else{
#ifdef _CRAY
						@(SC_PRE)TRSM(ftcs1, ftcs1, ftcs2, ftcs3, &iknsupc, &nrhs, &alpha,
								lusup1, &nsupr1, &x[ii], &iknsupc);
#elif defined (USE_VENDOR_BLAS)
						@(pre)trsm_("L", "L", "N", "U", &iknsupc, &nrhs, &alpha,
								lusup1, &nsupr1, &x[ii], &iknsupc, 1, 1, 1, 1);
#else
						@(pre)trsm_("L", "L", "N", "U", &iknsupc, &nrhs, &alpha,
								lusup1, &nsupr1, &x[ii], &iknsupc);
#endif
					}

#if ( PROFlevel>=1 )
					TOC(t2, t1);
					stat[thread_id]->utime[SOL_TRSM] += t2;
#endif

@precision SINGLE DOUBLE
					stat[thread_id]->ops[SOLVE] += iknsupc * (iknsupc - 1) * nrhs;
@precision SCOMPLEX DCOMPLEX
					stat[thread_id]->ops[SOLVE] += 4 * iknsupc * (iknsupc - 1) * nrhs
								    + 10 * knsupc * nrhs; /* complex division */
@precision !

#if ( DEBUGlevel>=2 )
					printf("(%2d) Solve X[%2d]\n", iam, ik);
#endif

					/*
					 * Send Xk to process column Pc[k].
					 */

					if(LBtree_ptr[lk].empty_==NO) {
						//BcTree_forwardMessageSimple(LBtree_ptr[lk],&x[ii - XK_H],BcTree_GetMsgSize(LBtree_ptr[lk],'@(pre)')*nrhs+XK_H,'@(pre)');
						//C_BcTree_forwardMessageSimple(&LBtree_ptr[lk], &x[ii - XK_H], LBtree_ptr[lk].msgSize_*nrhs+XK_H);
                        C_BcTree_forwardMessage_onesided(&LBtree_ptr[lk], &x[ii - XK_H], LBtree_ptr[lk].msgSize_*nrhs+XK_H, BCcount, BCbase, &maxrecvsz,Pc);

					}

					/*
					 * Perform local block modifications.
					 */

// #ifdef _OPENMP
// #pragma	omp	task firstprivate (Llu,sizelsum,iknsupc,ii,ik,lsub1,x,rtemp,fmod,lsum,stat,nrhs,grid,xsup,recurlevel) private(lptr1,luptr1,nlb1,thread_id1) untied priority(1)
// #endif
					{
						nlb1 = lsub1[0] - 1;

						@(pre)lsum_fmod_inv_master_onesided(lsum, x, &x[ii], rtemp, nrhs, iknsupc, ik,
								fmod, nlb1, xsup,
								grid, Llu, stat,sizelsum,sizertemp,1+recurlevel,maxsuper,thread_id,num_thread,
								RDcount, RDbase, BCcount, BCbase, Pc, maxrecvsz);
					}

					// } /* if frecv[lk] == 0 */
				} /* if iam == p */
			} /* if fmod[lk] == 0 */
		}
		// }
@precision SINGLE DOUBLE
		stat[thread_id]->ops[SOLVE] += 2 * m * nrhs * knsupc;
@precision SCOMPLEX DCOMPLEX
		stat[thread_id]->ops[SOLVE] += 8 * m * nrhs * knsupc;
@precision !
	} /* end if nlb>0*/
} /* end @(pre)lsum_fmod_inv_master */


/************************************************************************/
void @(pre)lsum_bmod_inv_master_onesided
/************************************************************************/
(
 @(type) *lsum,        /* Sum of local modifications.                    */
 @(type) *x,           /* X array (local).                               */
 @(type) *xk,          /* X[k].                                          */
 @(type) *rtemp,   /* Result of full matrix-vector multiply.             */
 int    nrhs,	      /* Number of right-hand sides.                    */
 int_t  k,            /* The k-th component of X.                       */
 int  *bmod,        /* Modification count for L-solve.                */
 int_t  *Urbs,        /* Number of row blocks in each block column of U.*/
 Ucb_indptr_t **Ucb_indptr,/* Vertical linked list pointing to Uindex[].*/
 int_t  **Ucb_valptr, /* Vertical linked list pointing to Unzval[].     */
 int_t  *xsup,
 gridinfo_t *grid,
 @(pre)LocalLU_t *Llu,
 SuperLUStat_t **stat,
 int_t sizelsum,
 int_t sizertemp,
 int thread_id,
 int num_thread,
 int* RDcount,
 long* RDbase,
 int* BCcount,
 long* BCbase,
 int Pc,
 int maxrecvsz
 )
{
	/*
	 * Purpose
	 * =======
	 *   Perform local block modifications: lsum[i] -= U_i,k * X[k].
	 */
@precision SINGLE DOUBLE
    @(type) alpha = 1.0, beta = 0.0;
@precision SCOMPLEX DCOMPLEX
    @(type) alpha = {1.0, 0.0}, beta = {0.0, 0.0};
@precision !
	int    iam, iknsupc, knsupc, myrow, nsupr, p, pi;
	int_t  fnz, gik, gikcol, i, ii, ik, ikfrow, iklrow, il, irow,
	       j, jj, lk, lk1, nub, ub, uptr;
	int_t  *usub;
	@(type) *uval, *dest, *y;
	int_t  *lsub;
	@(type) *lusup;
	int_t  *ilsum = Llu->ilsum; /* Starting position of each supernode in lsum.   */
	int *brecv = Llu->brecv;
	int  **bsendx_plist = Llu->bsendx_plist;
	C_Tree  *UBtree_ptr = Llu->UBtree_ptr;
	C_Tree  *URtree_ptr = Llu->URtree_ptr;
	MPI_Status status;
	int test_flag;
	int_t bmod_tmp;
	int thread_id1;
	@(type) *rtemp_loc;
	@(type) temp;
	@(type) *Uinv;/* Inverse of diagonal block */

	double t1, t2;
	float msg_vol = 0, msg_cnt = 0;
	int_t Nchunk, nub_loc,remainder,nn,lbstart,lbend;
	int_t iword = sizeof(int_t);
	int_t dword = sizeof (@(mod_type));
	int aln_d,aln_i;
	aln_d = 1; //ceil(CACHELINE/(double)dword);
	aln_i = 1; //ceil(CACHELINE/(double)iword);


	rtemp_loc = &rtemp[sizertemp* thread_id];


	iam = grid->iam;
	myrow = MYROW( iam, grid );
	knsupc = SuperSize( k );
	lk = LBj( k, grid ); /* Local block number, column-wise. */
	nub = Urbs[lk];      /* Number of U blocks in block column lk */

	// printf("Urbs2[lk] %5d lk %5d nub %5d\n",Urbs2[lk],lk,nub);
	// fflush(stdout);

	if(nub>num_thread){
	// if(nub>0){
		Nchunk=num_thread;
		nub_loc = floor(((double)nub)/Nchunk);
		remainder = nub % Nchunk;

//#ifdef _OPENMP
//#pragma	omp	taskloop firstprivate (stat) private (thread_id1,nn,lbstart,lbend,ub,temp,rtemp_loc,ik,gik,usub,uval,iknsupc,il,i,irow,jj,t1,t2,j,ikfrow,iklrow,dest,y,uptr,fnz) untied
//#endif
		for (nn=0;nn<Nchunk;++nn){

#ifdef _OPENMP
			thread_id1 = omp_get_thread_num ();
#else
			thread_id1 = 0;
#endif
			rtemp_loc = &rtemp[sizertemp* thread_id1];

#if ( PROFlevel>=1 )
			TIC(t1);
#endif

			if(nn<remainder){
				lbstart = nn*(nub_loc+1);
				lbend = (nn+1)*(nub_loc+1);
			}else{
				lbstart = remainder+nn*nub_loc;
				lbend = remainder + (nn+1)*nub_loc;
			}
			for (ub = lbstart; ub < lbend; ++ub){
				ik = Ucb_indptr[lk][ub].lbnum; /* Local block number, row-wise. */
				usub = Llu->Ufstnz_br_ptr[ik];
				uval = Llu->Unzval_br_ptr[ik];
				i = Ucb_indptr[lk][ub].indpos; /* Start of the block in usub[]. */
				i += UB_DESCRIPTOR;
				il = LSUM_BLK( ik );
				gik = ik * grid->nprow + myrow;/* Global block number, row-wise. */
				iknsupc = SuperSize( gik );
				ikfrow = FstBlockC( gik );
				iklrow = FstBlockC( gik+1 );

				RHS_ITERATE(j) {
					dest = &lsum[il + j*iknsupc+sizelsum*thread_id1];
					y = &xk[j*knsupc];
					uptr = Ucb_valptr[lk][ub]; /* Start of the block in uval[]. */
					for (jj = 0; jj < knsupc; ++jj) {
						fnz = usub[i + jj];
						if ( fnz < iklrow ) { /* Nonzero segment. */
							/* AXPY */
//#ifdef _OPENMP
//#pragma omp simd // In complex case, this SIMD loop has 2 instructions, the compiler may generate incoreect code, so need to disable this omp simd
//#endif
							for (irow = fnz; irow < iklrow; ++irow)
@precision SINGLE DOUBLE
								dest[irow - ikfrow] -= uval[uptr++] * y[jj];
							stat[thread_id1]->ops[SOLVE] += 2 * (iklrow - fnz);
@precision SCOMPLEX DCOMPLEX
								{
								@(pre)@(pre)_mult(&temp, &uval[uptr], &y[jj]);
								@(pre)_sub(&dest[irow - ikfrow], &dest[irow - ikfrow],
									  &temp);
								++uptr;
								}
							stat[thread_id1]->ops[SOLVE] += 8 * (iklrow - fnz);
@precision !

						}
					} /* for jj ... */
				}
			}
#if ( PROFlevel>=1 )
			TOC(t2, t1);
			stat[thread_id1]->utime[SOL_GEMM] += t2;
#endif
		}

	}else{
		rtemp_loc = &rtemp[sizertemp* thread_id];
#if ( PROFlevel>=1 )
		TIC(t1);
#endif
		for (ub = 0; ub < nub; ++ub) {
			ik = Ucb_indptr[lk][ub].lbnum; /* Local block number, row-wise. */
			usub = Llu->Ufstnz_br_ptr[ik];
			uval = Llu->Unzval_br_ptr[ik];
			i = Ucb_indptr[lk][ub].indpos; /* Start of the block in usub[]. */
			i += UB_DESCRIPTOR;
			il = LSUM_BLK( ik );
			gik = ik * grid->nprow + myrow;/* Global block number, row-wise. */
			iknsupc = SuperSize( gik );
			ikfrow = FstBlockC( gik );
			iklrow = FstBlockC( gik+1 );

			RHS_ITERATE(j) {
				dest = &lsum[il + j*iknsupc+sizelsum*thread_id];
				y = &xk[j*knsupc];
				uptr = Ucb_valptr[lk][ub]; /* Start of the block in uval[]. */
				for (jj = 0; jj < knsupc; ++jj) {
					fnz = usub[i + jj];
					if ( fnz < iklrow ) { /* Nonzero segment. */
						/* AXPY */
//#ifdef _OPENMP
//#pragma omp simd // In complex case, this SIMD loop has 2 instructions, the compiler may generate incoreect code, so need to disable this omp simd
//#endif
						for (irow = fnz; irow < iklrow; ++irow)
@precision SINGLE DOUBLE
							dest[irow - ikfrow] -= uval[uptr++] * y[jj];
						stat[thread_id]->ops[SOLVE] += 2 * (iklrow - fnz);
@precision SCOMPLEX DCOMPLEX
							{
							@(pre)@(pre)_mult(&temp, &uval[uptr], &y[jj]);
							@(pre)_sub(&dest[irow - ikfrow], &dest[irow - ikfrow],
								  &temp);
							++uptr;
							}
						stat[thread_id]->ops[SOLVE] += 8 * (iklrow - fnz);
@precision !

					}
				} /* for jj ... */
			}
		}
#if ( PROFlevel>=1 )
		TOC(t2, t1);
		stat[thread_id]->utime[SOL_GEMM] += t2;
#endif
	}


	rtemp_loc = &rtemp[sizertemp* thread_id];
	for (ub = 0; ub < nub; ++ub){
		ik = Ucb_indptr[lk][ub].lbnum; /* Local block number, row-wise. */
		il = LSUM_BLK( ik );
		gik = ik * grid->nprow + myrow;/* Global block number, row-wise. */
		iknsupc = SuperSize( gik );

	// #ifdef _OPENMP
	// #pragma omp atomic capture
	// #endif
		bmod_tmp=--bmod[ik*aln_i];

		if ( bmod_tmp == 0 ) { /* Local accumulation done. */
			gikcol = PCOL( gik, grid );
			p = PNUM( myrow, gikcol, grid );
			if ( iam != p ) {
				for (ii=1;ii<num_thread;ii++)
					// if(ii!=thread_id)
		#ifdef _OPENMP
		#pragma omp simd
		#endif
					for (jj=0;jj<iknsupc*nrhs;jj++)
@precision SINGLE DOUBLE
						lsum[il + jj ] += lsum[il + jj + ii*sizelsum];
@precision SCOMPLEX DCOMPLEX
						@(pre)_add(&lsum[il + jj ],
							  &lsum[il + jj ],
							  &lsum[il + jj + ii*sizelsum]);
@precision !
				//RdTree_forwardMessageSimple(URtree_ptr[ik],&lsum[il - LSUM_H ],RdTree_GetMsgSize(URtree_ptr[ik],'@(pre)')*nrhs+LSUM_H,'@(pre)');
				//C_RdTree_forwardMessageSimple(&URtree_ptr[ik],&lsum[il - LSUM_H ],URtree_ptr[ik].msgSize_*nrhs+LSUM_H);
				C_RdTree_forwardMessage_onesided(&URtree_ptr[ik],&lsum[il - LSUM_H ],URtree_ptr[ik].msgSize_*nrhs+LSUM_H, RDcount, RDbase, &maxrecvsz, Pc);


#if ( DEBUGlevel>=2 )
				printf("(%2d) Sent LSUM[%2.0f], size %2d, to P %2d\n",
						iam, lsum[il-LSUM_H], iknsupc*nrhs+LSUM_H, p);
#endif
			} else { /* Diagonal process: X[i] += lsum[i]. */

#if ( PROFlevel>=1 )
				TIC(t1);
#endif
				for (ii=1;ii<num_thread;ii++)
					// if(ii!=thread_id)
		#ifdef _OPENMP
		#pragma omp simd
		#endif
					for (jj=0;jj<iknsupc*nrhs;jj++)
@precision SINGLE DOUBLE
						lsum[il + jj ] += lsum[il + jj + ii*sizelsum];
@precision SCOMPLEX DCOMPLEX
						@(pre)_add(&lsum[il + jj ],
							  &lsum[il + jj ],
							  &lsum[il + jj + ii*sizelsum]);
@precision !

				ii = X_BLK( ik );
				dest = &x[ii];

				RHS_ITERATE(j)
		#ifdef _OPENMP
		#pragma omp simd
		#endif
					for (i = 0; i < iknsupc; ++i)
@precision SINGLE DOUBLE
						dest[i + j*iknsupc] += lsum[i + il + j*iknsupc];
@precision SCOMPLEX DCOMPLEX
						@(pre)_add(&dest[i + j*iknsupc],
							  &dest[i + j*iknsupc],
							  &lsum[i + il + j*iknsupc]);
@precision !

				// if ( !brecv[ik] ) { /* Becomes a leaf node. */
					// bmod[ik] = -1; /* Do not solve X[k] in the future. */
					lk1 = LBj( gik, grid ); /* Local block number. */
					lsub = Llu->Lrowind_bc_ptr[lk1];
					lusup = Llu->Lnzval_bc_ptr[lk1];
					nsupr = lsub[1];

					if(Llu->inv == 1){
						Uinv = Llu->Uinv_bc_ptr[lk1];
#ifdef _CRAY
						@(SC_PRE)GEMM( ftcs2, ftcs2, &iknsupc, &nrhs, &iknsupc,
								&alpha, Uinv, &iknsupc, &x[ii],
								&iknsupc, &beta, rtemp_loc, &iknsupc );
#elif defined (USE_VENDOR_BLAS)
						@(pre)gemm_( "N", "N", &iknsupc, &nrhs, &iknsupc,
								&alpha, Uinv, &iknsupc, &x[ii],
								&iknsupc, &beta, rtemp_loc, &iknsupc, 1, 1 );
#else
						@(pre)gemm_( "N", "N", &iknsupc, &nrhs, &iknsupc,
								&alpha, Uinv, &iknsupc, &x[ii],
								&iknsupc, &beta, rtemp_loc, &iknsupc );
#endif
			#ifdef _OPENMP
			#pragma omp simd
			#endif
						for (i=0 ; i<iknsupc*nrhs ; i++){
@precision SINGLE DOUBLE
							x[ii+i] = rtemp_loc[i];
@precision SCOMPLEX DCOMPLEX
							@(pre)_copy(&x[ii+i],&rtemp_loc[i]);
@precision !
						}
					}else{
#ifdef _CRAY
						@(SC_PRE)TRSM(ftcs1, ftcs3, ftcs2, ftcs2, &iknsupc, &nrhs, &alpha,
								lusup, &nsupr, &x[ii], &iknsupc);
#elif defined (USE_VENDOR_BLAS)
						@(pre)trsm_("L", "U", "N", "N", &iknsupc, &nrhs, &alpha,
								lusup, &nsupr, &x[ii], &iknsupc, 1, 1, 1, 1);
#else
						@(pre)trsm_("L", "U", "N", "N", &iknsupc, &nrhs, &alpha,
								lusup, &nsupr, &x[ii], &iknsupc);
#endif
					}

#if ( PROFlevel>=1 )
					TOC(t2, t1);
					stat[thread_id]->utime[SOL_TRSM] += t2;
#endif
@precision SINGLE DOUBLE
					stat[thread_id]->ops[SOLVE] += iknsupc * (iknsupc + 1) * nrhs;
@precision SCOMPLEX DCOMPLEX
					stat[thread_id]->ops[SOLVE] += 4 * iknsupc * (iknsupc + 1) * nrhs
					+ 10 * knsupc * nrhs; /* complex division */
@precision !
#if ( DEBUGlevel>=2 )
					printf("(%2d) Solve X[%2d]\n", iam, gik);
#endif

					/*
					 * Send Xk to process column Pc[k].
					 */

					 // for (i=0 ; i<iknsupc*nrhs ; i++){
						// printf("xre: %f\n",x[ii+i]);
						// fflush(stdout);
					// }
					if(UBtree_ptr[lk1].empty_==NO){
					  //BcTree_forwardMessageSimple(UBtree_ptr[lk1],&x[ii - XK_H],BcTree_GetMsgSize(UBtree_ptr[lk1],'@(pre)')*nrhs+XK_H,'@(pre)');
					  //C_BcTree_forwardMessageSimple(&UBtree_ptr[lk1], &x[ii - XK_H], UBtree_ptr[lk1].msgSize_*nrhs+XK_H);
					  C_BcTree_forwardMessage_onesided(&UBtree_ptr[lk1], &x[ii - XK_H], UBtree_ptr[lk1].msgSize_*nrhs+XK_H, BCcount, BCbase, &maxrecvsz,Pc);

					}

					/*
					 * Perform local block modifications.
					 */
					if ( Urbs[lk1] ){
// #ifdef _OPENMP
// #pragma	omp	task firstprivate (Ucb_indptr,Ucb_valptr,Llu,sizelsum,ii,gik,x,rtemp,bmod,Urbs,lsum,stat,nrhs,grid,xsup) untied
// #endif
						{
						@(pre)lsum_bmod_inv_master_onesided(lsum, x, &x[ii], rtemp, nrhs, gik, bmod, Urbs,
								Ucb_indptr, Ucb_valptr, xsup, grid, Llu,
								stat, sizelsum,sizertemp,thread_id,num_thread,
								RDcount, RDbase, BCcount, BCbase, Pc, maxrecvsz);
						}
					}
				// } /* if brecv[ik] == 0 */
			}
		} /* if bmod[ik] == 0 */
	}

} /* @(pre)lsum_bmod_inv_master */
#endif


